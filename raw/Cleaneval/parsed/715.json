{
  "url": "http://www.softlookup.com/tutorial/SQL/ch03.asp",
  "file_number": "715",
  "content_hash": "16f79130b02ca97a4c8d8bccd397364ab28076036172f054d6b1a65f46f95b51",
  "total_blocks": 562,
  "retained_blocks": 393,
  "ignored_blocks": 169,
  "blocks": [
    {
      "tag": "div",
      "text": "BEGIN RICH-MEDIA BURST! CODE END BURST CODE Free Tutorials HTML Learn HTML Learn CSS Learn XML Learn WML Database Learn Access Learn Data-VB Learn Oracle Learn SQL Programming Learn C++ Learn JavaScript Learn Vbscript Learn VisualBasic"
    },
    {
      "tag": "h1",
      "text": "- Chapter 3 - Expressions, Conditions, and Operators"
    },
    {
      "tag": "h2",
      "text": "Objectives"
    },
    {
      "tag": "p",
      "text": "On Chapter 2, \"Introduction to the Query: The SELECT Statement,\"\r\nyou used SELECT and FROM to manipulate data in interesting (and\r\nuseful) ways. ToChapter you learn more about SELECT and FROM and expand\r\nthe basic query with some new terms to go with query, table, and row, as well as\r\na new clause and a group of handy items called operators. When the sun sets on Day\r\n3, you will Know what an expression is and how to use it Know what a condition is and how to use it Be familiar with the basic uses of the WHERE clause Be able to use arithmetic, comparison, character, logical, and set operators Have a working knowledge of some miscellaneous operators NOTE: We used Oracle's Personal Oracle7\r\n\tto generate today's examples. Other implementations of SQL may differ slightly in\r\n\tthe way in which commands are entered or output is displayed, but the results are\r\n\tbasically the same for all implementations that conform to the ANSI standard."
    },
    {
      "tag": "h2",
      "text": "Expressions"
    },
    {
      "tag": "p",
      "text": "The definition of an expression is simple: An expression returns a value.\r\nExpression types are very broad, covering different data types such as String, Numeric,\r\nand Boolean. In fact, pretty much anything following a clause ( SELECT or FROM , for example) is an expression. In the following example amount is an expression that returns the value contained in the amount column."
    },
    {
      "tag": "pre",
      "text": "SELECT amount FROM checks;"
    },
    {
      "tag": "p",
      "text": "In the following statement NAME, ADDRESS, PHONE and ADDRESSguide are expressions:"
    },
    {
      "tag": "pre",
      "text": "SELECT NAME, ADDRESS, PHONE\r\nFROM ADDRESSguide;"
    },
    {
      "tag": "p",
      "text": "Now, examine the following expression:"
    },
    {
      "tag": "pre",
      "text": "WHERE NAME = 'BROWN'"
    },
    {
      "tag": "p",
      "text": "It contains a condition, NAME = 'BROWN' , which is an example of a Boolean\r\nexpression. NAME = 'BROWN' will be either TRUE or FALSE ,\r\ndepending on the condition = ."
    },
    {
      "tag": "h2",
      "text": "Conditions"
    },
    {
      "tag": "p",
      "text": "If you ever want to find a particular item or group of items in your database,\r\nyou need one or more conditions. Conditions are contained in the WHERE clause.\r\nIn the preceding example, the condition is"
    },
    {
      "tag": "pre",
      "text": "NAME = 'BROWN'"
    },
    {
      "tag": "p",
      "text": "To find everyone in your organization who worked more than 100 hours\r\nlast month, your condition would be"
    },
    {
      "tag": "pre",
      "text": "NUMBEROFHOURS > 100"
    },
    {
      "tag": "p",
      "text": "Conditions enable you to make selective queries. In their most common form, conditions\r\ncomprise a variable, a constant, and a comparison operator. In the first example\r\nthe variable is NAME , the constant is 'BROWN' , and the comparison\r\noperator is = . In the second example the variable is NUMBEROFHOURS ,\r\nthe constant is 100 , and the comparison operator is > . You need\r\nto know about two more elements before you can write conditional queries: the WHERE clause and operators."
    },
    {
      "tag": "h3",
      "text": "The WHERE Clause"
    },
    {
      "tag": "p",
      "text": "The syntax of the WHERE clause is"
    },
    {
      "tag": "h5",
      "text": "SYNTAX:"
    },
    {
      "tag": "pre",
      "text": "WHERE <SEARCH CONDITION>"
    },
    {
      "tag": "p",
      "text": "SELECT , FROM , and WHERE are the three most frequently\r\nused clauses in SQL. WHERE simply causes your queries to be more selective.\r\nWithout the WHERE clause, the most useful thing you could do with a query\r\nis display all records in the selected table(s). For example:"
    },
    {
      "tag": "h5",
      "text": "INPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT * FROM BIKES;"
    },
    {
      "tag": "p",
      "text": "lists all rows of data in the table BIKES ."
    },
    {
      "tag": "h5",
      "text": "OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "NAME           FRAMESIZE COMPOSITION  MILESRIDDEN TYPE\r\n-------------- --------- ------------ ----------- -------\r\nTREK 2300           22.5 CARBON FIBER        3500 RACING\r\nBURLEY                22 STEEL               2000 TANDEM\r\nGIANT                 19 STEEL               1500 COMMUTER\r\nFUJI                  20 STEEL                500 TOURING\r\nSPECIALIZED           16 STEEL                100 MOUNTAIN\r\nCANNONDALE          22.5 ALUMINUM            3000 RACING 6 rows selected."
    },
    {
      "tag": "p",
      "text": "If you wanted a particular bike, you could type"
    },
    {
      "tag": "h5",
      "text": "INPUT/OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT *\r\n     FROM BIKES\r\n     WHERE NAME = 'BURLEY';"
    },
    {
      "tag": "p",
      "text": "which would yield only one record:"
    },
    {
      "tag": "pre",
      "text": "NAME           FRAMESIZE COMPOSITION    MILESRIDDEN TYPE\r\n-------------- --------- -------------- ----------- -------\r\nBURLEY                22 STEEL                 2000 TANDEM"
    },
    {
      "tag": "h5",
      "text": "ANALYSIS:"
    },
    {
      "tag": "p",
      "text": "This simple example shows how you can place a condition on the data that you want\r\nto retrieve."
    },
    {
      "tag": "h2",
      "text": "Operators"
    },
    {
      "tag": "p",
      "text": "Operators are the elements you use inside an expression to articulate how you\r\nwant specified conditions to retrieve data. Operators fall into six groups: arithmetic,\r\ncomparison, character, logical, set, and miscellaneous."
    },
    {
      "tag": "h3",
      "text": "Arithmetic Operators"
    },
    {
      "tag": "p",
      "text": "The arithmetic operators are plus ( + ), minus (-), divide ( / ),\r\nmultiply ( * ), and modulo ( % ). The first four are self-explanatory.\r\nModulo returns the integer remainder of a division. Here are two examples:"
    },
    {
      "tag": "pre",
      "text": "5 % 2 = 1\r\n6 % 2 = 0"
    },
    {
      "tag": "p",
      "text": "The modulo operator does not work with data types that have decimals, such as\r\nReal or Number. If you place several of these arithmetic operators in an expression without any\r\nparentheses, the operators are resolved in this order: multiplication, division,\r\nmodulo, addition, and subtraction. For example, the expression"
    },
    {
      "tag": "pre",
      "text": "2*6+9/3"
    },
    {
      "tag": "p",
      "text": "equals"
    },
    {
      "tag": "pre",
      "text": "12 + 3 = 15"
    },
    {
      "tag": "p",
      "text": "However, the expression"
    },
    {
      "tag": "pre",
      "text": "2 * (6 + 9) / 3"
    },
    {
      "tag": "p",
      "text": "equals"
    },
    {
      "tag": "pre",
      "text": "2 * 15 / 3 = 10"
    },
    {
      "tag": "p",
      "text": "Watch where you put those parentheses! Sometimes the expression does exactly what\r\nyou tell it to do, rather than what you want it to do. The following sections examine the arithmetic operators in some detail and give\r\nyou a chance to write some queries."
    },
    {
      "tag": "h4",
      "text": "Plus (+)"
    },
    {
      "tag": "p",
      "text": "You can use the plus sign in several ways. Type the following statement to display\r\nthe PRICE table:"
    },
    {
      "tag": "h5",
      "text": "INPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT * FROM PRICE;"
    },
    {
      "tag": "h5",
      "text": "OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "ITEM            WHOLESALE\r\n-------------- ----------\r\nTOMATOES              .34\r\nPOTATOES              .51\r\nBANANAS               .67\r\nTURNIPS               .45\r\nCHEESE                .89\r\nAPPLES                .23 6 rows selected."
    },
    {
      "tag": "p",
      "text": "Now type:"
    },
    {
      "tag": "h5",
      "text": "INPUT/OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT ITEM, WHOLESALE, WHOLESALE + 0.15\r\n    FROM PRICE;"
    },
    {
      "tag": "p",
      "text": "Here the + adds 15 cents to each price to produce the following:"
    },
    {
      "tag": "pre",
      "text": "ITEM           WHOLESALE WHOLESALE+0.15\r\n-------------- --------- --------------\r\nTOMATOES             .34            .49\r\nPOTATOES             .51            .66\r\nBANANAS              .67            .82\r\nTURNIPS              .45            .60\r\nCHEESE               .89           1.04\r\nAPPLES               .23            .38 6 rows selected."
    },
    {
      "tag": "h5",
      "text": "ANALYSIS:"
    },
    {
      "tag": "p",
      "text": "What is this last column with the unattractive column heading WHOLESALE+0.15 ?\r\nIt's not in the original table. (Remember, you used * in the SELECT clause, which causes all the columns to be shown.) SQL allows you to create a virtual\r\nor derived column by combining or modifying existing columns. Retype the original entry:"
    },
    {
      "tag": "h5",
      "text": "INPUT/OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT * FROM PRICE;"
    },
    {
      "tag": "p",
      "text": "The following table results:"
    },
    {
      "tag": "pre",
      "text": "ITEM           WHOLESALE\r\n-------------- ---------\r\nTOMATOES             .34\r\nPOTATOES             .51\r\nBANANAS              .67\r\nTURNIPS              .45\r\nCHEESE               .89\r\nAPPLES               .23 6 rows selected."
    },
    {
      "tag": "h5",
      "text": "ANALYSIS:"
    },
    {
      "tag": "p",
      "text": "The output confirms that the original data has not been changed and that the column\r\nheading WHOLESALE+0.15 is not a permanent part of it. In fact, the column\r\nheading is so unattractive that you should do something about it. Type the following:"
    },
    {
      "tag": "h5",
      "text": "INPUT/OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT ITEM, WHOLESALE, (WHOLESALE + 0.15) RETAIL\r\n    FROM PRICE;"
    },
    {
      "tag": "p",
      "text": "Here's the result:"
    },
    {
      "tag": "pre",
      "text": "ITEM           WHOLESALE  RETAIL\r\n-------------- ---------  ------\r\nTOMATOES             .34     .49\r\nPOTATOES             .51     .66\r\nBANANAS              .67     .82\r\nTURNIPS              .45     .60\r\nCHEESE               .89    1.04\r\nAPPLES               .23     .38 6 rows selected."
    },
    {
      "tag": "h5",
      "text": "ANALYSIS:"
    },
    {
      "tag": "p",
      "text": "This is wonderful! Not only can you create new columns, but you can also rename\r\nthem on the fly. You can rename any of the columns using the syntax column_name\r\nalias (note the space between column_name and alias ). For example, the query"
    },
    {
      "tag": "h5",
      "text": "INPUT/OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT ITEM PRODUCE, WHOLESALE, WHOLESALE + 0.25 RETAIL\r\n     FROM PRICE;"
    },
    {
      "tag": "p",
      "text": "renames the columns as follows:"
    },
    {
      "tag": "pre",
      "text": "PRODUCE        WHOLESALE    RETAIL\r\n-------------- --------- ---------\r\nTOMATOES             .34       .59\r\nPOTATOES             .51       .76\r\nBANANAS              .67       .92\r\nTURNIPS              .45       .70\r\nCHEESE               .89      1.14\r\nAPPLES               .23       .48"
    },
    {
      "tag": "p",
      "text": "NOTE: Some implementations of SQL use\r\n\tthe syntax <column name = alias> . The preceding example would be written\r\n\tas follows:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT ITEM = PRODUCE,\r\n     WHOLESALE,\r\n     WHOLESALE + 0.25 = RETAIL,\r\n     FROM PRICE;"
    },
    {
      "tag": "p",
      "text": "Check your implementation for the exact syntax. You might be wondering what use aliasing is if you are not using command-line\r\nSQL. Fair enough. Have you ever wondered how report builders work? Someday, when\r\nyou are asked to write a report generator, you'll remember this and not spend weeks\r\nreinventing what Dr. Codd and IBM have wrought. So far, you have seen two uses of the plus sign. The first instance was the use\r\nof the plus sign in the SELECT clause to perform a calculation on the data\r\nand display the calculation. The second use of the plus sign is in the WHERE clause. Using operators in the WHERE clause gives you more flexibility when\r\nyou specify conditions for retrieving data. In some implementations of SQL, the plus sign does double duty as a character\r\noperator. You'll see that side of the plus a little later today."
    },
    {
      "tag": "h4",
      "text": "Minus (-)"
    },
    {
      "tag": "p",
      "text": "Minus also has two uses. First, it can change the sign of a number. You can use\r\nthe table HILOW to demonstrate this function."
    },
    {
      "tag": "h5",
      "text": "INPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT * FROM HILOW;"
    },
    {
      "tag": "h5",
      "text": "OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "STATE      HIGHTEMP   LOWTEMP\r\n---------- -------- ---------\r\nCA              -50       120\r\nFL               20       110\r\nLA               15        99\r\nND              -70       101\r\nNE              -60       100"
    },
    {
      "tag": "p",
      "text": "For example, here's a way to manipulate the data:"
    },
    {
      "tag": "h5",
      "text": "INPUT/OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT STATE, -HIGHTEMP LOWS, -LOWTEMP HIGHS\r\n     FROM HILOW; STATE          LOWS     HIGHS\r\n---------- -------- ---------\r\nCA               50      -120\r\nFL              -20      -110\r\nLA              -15       -99\r\nND               70      -101\r\nNE               60      -100"
    },
    {
      "tag": "p",
      "text": "The second (and obvious) use of the minus sign is to subtract one column from\r\nanother. For example:"
    },
    {
      "tag": "h5",
      "text": "INPUT/OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT STATE, 2 HIGHTEMP LOWS, 3 LOWTEMP HIGHS, 4 (LOWTEMP - HIGHTEMP) DIFFERENCE 5 FROM HILOW; STATE          LOWS    HIGHS DIFFERENCE\r\n---------- -------- -------- ----------\r\nCA              -50      120        170\r\nFL               20      110         90\r\nLA               15       99         84\r\nND              -70      101        171\r\nNE              -60      100        160"
    },
    {
      "tag": "p",
      "text": "Notice the use of aliases to fix the data that was entered incorrectly. This remedy\r\nis merely a temporary patch, though, and not a permanent fix. You should see to it\r\nthat the data is corrected and entered correctly in the future. On Chapter 21, \"Common\r\nSQL Mistakes/Errors and Resolutions,\" you'll learn how to correct bad data. This query not only fixed (at least visually) the incorrect data but also created\r\na new column containing the difference between the highs and lows of each state. If you accidentally use the minus sign on a character field, you get something\r\nlike this:"
    },
    {
      "tag": "h5",
      "text": "INPUT/OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT -STATE FROM HILOW; ERROR:\r\nORA-01722: invalid number\r\nno rows selected"
    },
    {
      "tag": "p",
      "text": "The exact error message varies with implementation, but the result is the same."
    },
    {
      "tag": "h4",
      "text": "Divide (/)"
    },
    {
      "tag": "p",
      "text": "The division operator has only the one obvious meaning. Using the table PRICE ,\r\ntype the following:"
    },
    {
      "tag": "h5",
      "text": "INPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT * FROM PRICE;"
    },
    {
      "tag": "h5",
      "text": "OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "ITEM           WHOLESALE\r\n-------------- ---------\r\nTOMATOES             .34\r\nPOTATOES             .51\r\nBANANAS              .67\r\nTURNIPS              .45\r\nCHEESE               .89\r\nAPPLES               .23 6 rows selected."
    },
    {
      "tag": "p",
      "text": "You can show the effects of a two-for-one sale by typing the next statement:"
    },
    {
      "tag": "h5",
      "text": "INPUT/OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT ITEM, WHOLESALE, (WHOLESALE/2) SALEPRICE\r\n  2  FROM PRICE; ITEM           WHOLESALE SALEPRICE\r\n-------------- --------- ---------\r\nTOMATOES             .34       .17\r\nPOTATOES             .51      .255\r\nBANANAS              .67      .335\r\nTURNIPS              .45      .225\r\nCHEESE               .89      .445\r\nAPPLES               .23      .115 6 rows selected."
    },
    {
      "tag": "p",
      "text": "The use of division in the preceding SELECT statement is straightforward\r\n(except that coming up with half pennies can be tough)."
    },
    {
      "tag": "h4",
      "text": "Multiply (*)"
    },
    {
      "tag": "p",
      "text": "The multiplication operator is also straightforward. Again, using the PRICE table, type the following:"
    },
    {
      "tag": "h5",
      "text": "INPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT * FROM PRICE;"
    },
    {
      "tag": "h5",
      "text": "OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "ITEM           WHOLESALE\r\n-------------- ---------\r\nTOMATOES             .34\r\nPOTATOES             .51\r\nBANANAS              .67\r\nTURNIPS              .45\r\nCHEESE               .89\r\nAPPLES               .23 6 rows selected."
    },
    {
      "tag": "p",
      "text": "This query changes the table to reflect an across-the-board 10 percent discount:"
    },
    {
      "tag": "h5",
      "text": "INPUT/OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT ITEM, WHOLESALE, WHOLESALE * 0.9 NEWPRICE\r\n     FROM PRICE; ITEM           WHOLESALE  NEWPRICE\r\n-------------- ---------  --------\r\nTOMATOES             .34      .306\r\nPOTATOES             .51      .459\r\nBANANAS              .67      .603\r\nTURNIPS              .45      .405\r\nCHEESE               .89      .801\r\nAPPLES               .23      .207 6 rows selected."
    },
    {
      "tag": "p",
      "text": "These operators enable you to perform powerful calculations in a SELECT statement."
    },
    {
      "tag": "h4",
      "text": "Modulo (%)"
    },
    {
      "tag": "p",
      "text": "The modulo operator returns the integer remainder of the division operation. Using\r\nthe table REMAINS , type the following:"
    },
    {
      "tag": "h5",
      "text": "INPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT * FROM REMAINS;"
    },
    {
      "tag": "h5",
      "text": "OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "NUMERATOR  DENOMINATOR\r\n---------  ------------\r\n       10            5\r\n        8            3\r\n       23            9\r\n       40           17\r\n     1024           16\r\n       85           34 6 rows selected."
    },
    {
      "tag": "p",
      "text": "You can also create a new column, REMAINDER , to hold the values of NUMERATOR\r\n% DENOMINATOR :"
    },
    {
      "tag": "h5",
      "text": "INPUT/OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT NUMERATOR,\r\n     DENOMINATOR,\r\n     NUMERATOR%DENOMINATOR REMAINDER\r\n     FROM REMAINS; NUMERATOR DENOMINATOR REMAINDER\r\n--------- ----------- ---------\r\n       10           5         0\r\n        8           3         2\r\n       23           9         5\r\n       40          17         6\r\n     1024          16         0\r\n       85          34        17 6 rows selected."
    },
    {
      "tag": "p",
      "text": "Some implementations of SQL implement modulo as a function called MOD (see Chapter 4, \"Functions: Molding the Data You Retrieve\"). The following\r\nstatement produces results that are identical to the results in the preceding statement:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT NUMERATOR,\r\n     DENOMINATOR,\r\n     MOD(NUMERATOR,DENOMINATOR) REMAINDER\r\n     FROM REMAINS;"
    },
    {
      "tag": "h4",
      "text": "Precedence"
    },
    {
      "tag": "p",
      "text": "This section examines the use of precedence in a SELECT statement. Using\r\nthe database PRECEDENCE , type the following:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT * FROM PRECEDENCE; N1        N2        N3        N4\r\n--------- --------- --------- ---------\r\n        1         2         3         4\r\n       13        24        35        46\r\n        9         3        23         5\r\n       63         2        45         3\r\n        7         2         1         4"
    },
    {
      "tag": "p",
      "text": "Use the following code segment to test precedence:"
    },
    {
      "tag": "h5",
      "text": "INPUT/OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT\r\n  2  N1+N2*N3/N4,\r\n  3  (N1+N2)*N3/N4,\r\n  4  N1+(N2*N3)/N4\r\n  5  FROM PRECEDENCE; N1+N2*N3/N4 (N1+N2)*N3/N4 N1+(N2*N3)/N4\r\n----------- ------------- -------------\r\n        2.5          2.25           2.5\r\n   31.26087     28.152174      31.26087\r\n       22.8          55.2          22.8\r\n         93           975            93\r\n        7.5          2.25           7.5"
    },
    {
      "tag": "p",
      "text": "Notice that the first and last columns are identical. If you added a fourth column N1+N2* (N3/N4) , its values would also be identical to those of the current\r\nfirst and last columns."
    },
    {
      "tag": "h3",
      "text": "Comparison Operators"
    },
    {
      "tag": "p",
      "text": "True to their name, comparison operators compare expressions and return one of\r\nthree values: TRUE , FALSE , or Unknown . Wait a minute! Unknown ? TRUE and FALSE are self-explanatory, but what\r\nis Unknown ? To understand how you could get an Unknown , you need to know a little\r\nabout the concept of NULL . In database terms NULL is the absence\r\nof data in a field. It does not mean a column has a zero or a blank in it. Azero\r\nor a blank is a value. NULL means nothing is in that field. If you make\r\na comparison like Field = 9 and the only value for Field is NULL ,\r\nthe comparison will come back Unknown . Because Unknown is an uncomfortable\r\ncondition, most flavors of SQL change Unknown to FALSE and provide\r\na special operator, IS NULL , to test for a NULL condition. Here's an example of NULL : Suppose an entry in the PRICE table\r\ndoes not contain a value for WHOLESALE . The results of a query might look\r\nlike this:"
    },
    {
      "tag": "h5",
      "text": "INPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT * FROM PRICE;"
    },
    {
      "tag": "h5",
      "text": "OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "ITEM            WHOLESALE\r\n-------------- ----------\r\nTOMATOES              .34\r\nPOTATOES              .51\r\nBANANAS               .67\r\nTURNIPS               .45\r\nCHEESE                .89\r\nAPPLES                .23\r\nORANGES"
    },
    {
      "tag": "p",
      "text": "Notice that nothing is printed out in the WHOLESALE field position for\r\noranges. The value for the field WHOLESALE for oranges is NULL .\r\nThe NULL is noticeable in this case because it is in a numeric column. However,\r\nif the NULL appeared in the ITEM column, it would be impossible\r\nto tell the difference between NULL and a blank. Try to find the NULL :"
    },
    {
      "tag": "h5",
      "text": "INPUT/OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT * 2 FROM PRICE 3 WHERE WHOLESALE IS NULL; ITEM            WHOLESALE\r\n-------------- ----------\r\nORANGES"
    },
    {
      "tag": "h5",
      "text": "ANALYSIS:"
    },
    {
      "tag": "p",
      "text": "As you can see by the output, ORANGES is the only item whose value for WHOLESALE is NULL or does not contain a value. What if you use\r\nthe equal sign ( = ) instead?"
    },
    {
      "tag": "h5",
      "text": "INPUT/OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT *\r\n     FROM PRICE\r\n     WHERE WHOLESALE = NULL; no rows selected"
    },
    {
      "tag": "h5",
      "text": "ANALYSIS:"
    },
    {
      "tag": "p",
      "text": "You didn't find anything because the comparison WHOLESALE = NULL returned\r\na FALSE --the result was unknown. It would be more appropriate to use an IS NULL instead of = , changing the WHERE statement to WHERE WHOLESALE IS NULL . In this case you would get all the rows where a NULL existed. This example also illustrates both the use of the most common comparison operator,\r\nthe equal sign ( = ), and the playground of all comparison operators, the WHERE clause. You already know about the WHERE clause, so here's\r\na brief look at the equal sign."
    },
    {
      "tag": "h4",
      "text": "Equal (=)"
    },
    {
      "tag": "p",
      "text": "Earlier toChapter you saw how some implementations of SQL use the equal sign in the SELECT clause to assign an alias. In the WHERE clause, the equal\r\nsign is the most commonly used comparison operator. Used alone, the equal sign is\r\na very convenient way of selecting one value out of many. Try this:"
    },
    {
      "tag": "h5",
      "text": "INPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT * FROM FRIENDS;"
    },
    {
      "tag": "h5",
      "text": "OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "LASTNAME       FIRSTNAME       AREACODE PHONE    ST ZIP\r\n-------------- -------------- --------- -------- -- -----\r\nBUNDY          AL                   100 555-1111 IL 22333\r\nMEZA           AL                   200 555-2222 UK\r\nMERRICK        BUD                  300 555-6666 CO 80212\r\nMAST           JD                   381 555-6767 LA 23456\r\nBULHER         FERRIS               345 555-3223 IL 23332"
    },
    {
      "tag": "p",
      "text": "Let's find JD's row. (On a short list this task appears trivial, but you may have\r\nmore friends than we do--or you may have a list with thousands of records.)"
    },
    {
      "tag": "h5",
      "text": "INPUT/OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT *\r\n     FROM FRIENDS\r\n     WHERE FIRSTNAME = 'JD'; LASTNAME       FIRSTNAME       AREACODE PHONE    ST ZIP\r\n-------------- -------------- --------- -------- -- -----\r\nMAST           JD                   381 555-6767 LA 23456"
    },
    {
      "tag": "p",
      "text": "We got the result that we expected. Try this:"
    },
    {
      "tag": "h5",
      "text": "INPUT/OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT *\r\n     FROM FRIENDS\r\n     WHERE FIRSTNAME = 'AL'; LASTNAME       FIRSTNAME       AREACODE PHONE    ST ZIP\r\n-------------- -------------- --------- -------- -- -----\r\nBUNDY          AL                   100 555-1111 IL 22333\r\nMEZA           AL                   200 555-2222 UK"
    },
    {
      "tag": "p",
      "text": "NOTE: Here you see that = can\r\n\tpull in multiple records. Notice that ZIP is blank on the second record. ZIP is a character field (you learn how to create and populate tables on\r\n\tChapter 8, \"Manipulating Data\"), and in this particular record the NULL demonstrates that a NULL in a character field is impossible to differentiate\r\n\tfrom a blank field. Here's another very important lesson concerning case sensitivity:"
    },
    {
      "tag": "h5",
      "text": "INPUT/OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT * FROM FRIENDS\r\n     WHERE FIRSTNAME = 'BUD'; FIRSTNAME\r\n--------------\r\nBUD\r\n1 row selected."
    },
    {
      "tag": "p",
      "text": "Now try this:"
    },
    {
      "tag": "h5",
      "text": "INPUT/OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> select * from friends\r\n     where firstname = 'Bud'; no rows selected."
    },
    {
      "tag": "h5",
      "text": "ANALYSIS:"
    },
    {
      "tag": "p",
      "text": "Even though SQL syntax is not case sensitive, data is. Most companies prefer to\r\nstore data in uppercase to provide data consistency. You should always store data\r\neither in all uppercase or in all lowercase. Mixing case creates difficulties when\r\nyou try to retrieve accurate data."
    },
    {
      "tag": "h4",
      "text": "Greater Than (>) and Greater Than or Equal To (>=)"
    },
    {
      "tag": "p",
      "text": "The greater than operator ( > ) works like this:"
    },
    {
      "tag": "h5",
      "text": "INPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT *\r\n     FROM FRIENDS\r\n     WHERE AREACODE > 300;"
    },
    {
      "tag": "h5",
      "text": "OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "LASTNAME       FIRSTNAME       AREACODE PHONE    ST ZIP\r\n-------------- -------------- --------- -------- -- -----\r\nMAST           JD                   381 555-6767 LA 23456\r\nBULHER         FERRIS               345 555-3223 IL 23332"
    },
    {
      "tag": "h5",
      "text": "ANALYSIS:"
    },
    {
      "tag": "p",
      "text": "This example found all the area codes greater than (but not including) 300 .\r\nTo include 300 , type this:"
    },
    {
      "tag": "h5",
      "text": "INPUT/OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT * 2 FROM FRIENDS 3 WHERE AREACODE >= 300; LASTNAME       FIRSTNAME       AREACODE PHONE    ST ZIP\r\n-------------- -------------- --------- -------- -- -----\r\nMERRICK        BUD                  300 555-6666 CO 80212\r\nMAST           JD                   381 555-6767 LA 23456\r\nBULHER         FERRIS               345 555-3223 IL 23332"
    },
    {
      "tag": "h5",
      "text": "ANALYSIS:"
    },
    {
      "tag": "p",
      "text": "With this change you get area codes starting at 300 and going up. You\r\ncould achieve the same results with the statement AREACODE > 299 . NOTE: Notice that no quotes surround 300 in this SQL statement. Number-defined fieldsnumber-defined fields do not require\r\n\tquotes."
    },
    {
      "tag": "h4",
      "text": "Less Than (<) and Less Than or Equal To (<=)"
    },
    {
      "tag": "p",
      "text": "As you might expect, these comparison operators work the same way as > and >= work, only in reverse:"
    },
    {
      "tag": "h5",
      "text": "INPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT * 2 FROM FRIENDS 3 WHERE STATE < 'LA';"
    },
    {
      "tag": "h5",
      "text": "OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "LASTNAME       FIRSTNAME       AREACODE PHONE    ST ZIP\r\n-------------- -------------- --------- -------- -- ------\r\nBUNDY          AL                   100 555-1111 IL 22333\r\nMERRICK        BUD                  300 555-6666 CO 80212\r\nBULHER         FERRIS               345 555-3223 IL 23332"
    },
    {
      "tag": "p",
      "text": "NOTE: How did STATE get changed\r\n\tto ST ? Because the column has only two characters, the column name is shortened\r\n\tto two characters in the returned rows. If the column name had been COWS ,\r\n\tit would come out CO . The widths of AREACODE and PHONE are wider than their column names, so they are not truncated."
    },
    {
      "tag": "h5",
      "text": "ANALYSIS:"
    },
    {
      "tag": "p",
      "text": "Wait a minute. Did you just use < on a character field? Of course\r\nyou did. You can use any of these operators on any data type. The result varies by\r\ndata type. For example, use lowercase in the following state search:"
    },
    {
      "tag": "h5",
      "text": "INPUT/OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT * 2 FROM FRIENDS 3 WHERE STATE < 'la'; LASTNAME       FIRSTNAME       AREACODE PHONE    ST ZIP\r\n-------------- -------------- --------- -------- -- -----\r\nBUNDY          AL                   100 555-1111 IL 22333\r\nMEZA           AL                   200 555-2222 UK\r\nMERRICK        BUD                  300 555-6666 CO 80212\r\nMAST           JD                   381 555-6767 LA 23456\r\nBULHER         FERRIS               345 555-3223 IL 23332"
    },
    {
      "tag": "h5",
      "text": "ANALYSIS:"
    },
    {
      "tag": "p",
      "text": "Uppercase is usually sorted before lowercase; therefore, the uppercase codes returned\r\nare less than 'la' . Again, to be safe, check your implementation. TIP: To be sure of how these operators\r\n\twill behave, check your language tables. Most PC implementations use the ASCII tables.\r\n\tSome other platforms use EBCDIC. To include the state of Louisiana in the original search, type"
    },
    {
      "tag": "h5",
      "text": "INPUT/OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT * 2 FROM FRIENDS 3 WHERE STATE <= 'LA'; LASTNAME       FIRSTNAME       AREACODE PHONE    ST ZIP\r\n-------------- -------------- --------- -------- -- -----\r\nBUNDY          AL                   100 555-1111 IL 22333\r\nMERRICK        BUD                  300 555-6666 CO 80212\r\nMAST           JD                   381 555-6767 LA 23456\r\nBULHER         FERRIS               345 555-3223 IL 23332"
    },
    {
      "tag": "h4",
      "text": "Inequalities (< > or !=)"
    },
    {
      "tag": "p",
      "text": "When you need to find everything except for certain data, use the inequality symbol,\r\nwhich can be either < > or != , depending on your SQL implementation.\r\nFor example, to find everyone who is not AL , type this:"
    },
    {
      "tag": "h5",
      "text": "INPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT * 2 FROM FRIENDS 3 WHERE FIRSTNAME <> 'AL';"
    },
    {
      "tag": "h5",
      "text": "OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "LASTNAME       FIRSTNAME       AREACODE PHONE    ST ZIP\r\n-------------- -------------- --------- -------- -- -----\r\nMERRICK        BUD                  300 555-6666 CO 80212\r\nMAST           JD                   381 555-6767 LA 23456\r\nBULHER         FERRIS               345 555-3223 IL 23332"
    },
    {
      "tag": "p",
      "text": "To find everyone not living in California, type this:"
    },
    {
      "tag": "h5",
      "text": "INPUT/OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT * 2 FROM FRIENDS 3 WHERE STATE != 'CA'; LASTNAME       FIRSTNAME       AREACODE PHONE    ST ZIP\r\n-------------- -------------- --------- -------- -- -----\r\nBUNDY          AL                   100 555-1111 IL 22333\r\nMEZA           AL                   200 555-2222 UK\r\nMERRICK        BUD                  300 555-6666 CO 80212\r\nMAST           JD                   381 555-6767 LA 23456\r\nBULHER         FERRIS               345 555-3223 IL 23332"
    },
    {
      "tag": "p",
      "text": "NOTE: Notice that both symbols, <> and != , can express \"not equals.\""
    },
    {
      "tag": "h3",
      "text": "Character Operators"
    },
    {
      "tag": "p",
      "text": "You can use character operators to manipulate the way character strings are represented,\r\nboth in the output of data and in the process of placing conditions on data to be\r\nretrieved. This section describes two character operators: the LIKE operator\r\nand the || operator, which conveys the concept of character concatenation."
    },
    {
      "tag": "h4",
      "text": "I Want to Be Like LIKE"
    },
    {
      "tag": "p",
      "text": "What if you wanted to select parts of a database that fit a pattern but weren't\r\nquite exact matches? You could use the equal sign and run through all the possible\r\ncases, but that process would be boring and time-consuming. Instead, you could use LIKE . Consider the following:"
    },
    {
      "tag": "h5",
      "text": "INPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT * FROM PARTS;"
    },
    {
      "tag": "h5",
      "text": "OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "NAME           LOCATION       PARTNUMBER\r\n-------------- -------------- ----------\r\nAPPENDIX       MID-STOMACH             1\r\nADAMS APPLE    THROAT                  2\r\nHEART          CHEST                   3\r\nSPINE          BACK                    4\r\nANVIL          EAR                     5\r\nKIDNEY         MID-BACK                6"
    },
    {
      "tag": "p",
      "text": "How can you find all the parts located in the back? Aquick visual inspection\r\nof this simple table shows that it has two parts, but unfortunately the locations\r\nhave slightly different names. Try this:"
    },
    {
      "tag": "h5",
      "text": "INPUT/OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT * 2 FROM PARTS 3 WHERE LOCATION LIKE '%BACK%'; NAME           LOCATION       PARTNUMBER\r\n-------------- -------------- ----------\r\nSPINE          BACK                    4\r\nKIDNEY         MID-BACK                6"
    },
    {
      "tag": "h5",
      "text": "ANALYSIS:"
    },
    {
      "tag": "p",
      "text": "You can see the use of the percent sign ( % ) in the statement after LIKE .\r\nWhen used inside a LIKE expression, % is a wildcard. What you asked for\r\nwas any occurrence of BACK in the column location. If you queried"
    },
    {
      "tag": "h5",
      "text": "INPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT *\r\n     FROM PARTS WHERE LOCATION LIKE 'BACK%';"
    },
    {
      "tag": "p",
      "text": "you would get any occurrence that started with BACK :"
    },
    {
      "tag": "h5",
      "text": "OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "NAME           LOCATION       PARTNUMBER\r\n-------------- -------------- ----------\r\nSPINE          BACK                    4"
    },
    {
      "tag": "p",
      "text": "If you queried"
    },
    {
      "tag": "h5",
      "text": "INPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT *\r\n     FROM PARTS WHERE NAME LIKE 'A%';"
    },
    {
      "tag": "p",
      "text": "you would get any name that starts with A :"
    },
    {
      "tag": "h5",
      "text": "OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "NAME           LOCATION       PARTNUMBER\r\n-------------- -------------- ----------\r\nAPPENDIX       MID-STOMACH             1\r\nADAMS APPLE    THROAT                  2\r\nANVIL          EAR                     5"
    },
    {
      "tag": "p",
      "text": "Is LIKE case sensitive? Try the next query to find out."
    },
    {
      "tag": "h5",
      "text": "INPUT/OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT *\r\n     FROM PARTS\r\n     WHERE NAME LIKE 'a%'; no rows selected"
    },
    {
      "tag": "h5",
      "text": "ANALYSIS:"
    },
    {
      "tag": "p",
      "text": "The answer is yes. References to data are always case sensitive. What if you want to find data that matches all but one character in a certain\r\npattern? In this case you could use a different type of wildcard: the underscore."
    },
    {
      "tag": "h4",
      "text": "Underscore (_)"
    },
    {
      "tag": "p",
      "text": "The underscore is the single-character wildcard. Using a modified version of the\r\ntable FRIENDS , type this:"
    },
    {
      "tag": "h5",
      "text": "INPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT * FROM FRIENDS;"
    },
    {
      "tag": "h5",
      "text": "OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "LASTNAME       FIRSTNAME       AREACODE PHONE    ST ZIP\r\n-------------- -------------- --------- -------- -- -----\r\nBUNDY          AL                   100 555-1111 IL 22333\r\nMEZA           AL                   200 555-2222 UK\r\nMERRICK        UD                   300 555-6666 CO 80212\r\nMAST           JD                   381 555-6767 LA 23456\r\nBULHER         FERRIS               345 555-3223 IL 23332\r\nPERKINS        ALTON                911 555-3116 CA 95633\r\nBOSS           SIR                  204 555-2345 CT 95633"
    },
    {
      "tag": "p",
      "text": "To find all the records where STATE starts with C , type the\r\nfollowing:"
    },
    {
      "tag": "h5",
      "text": "INPUT/OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT * 2 FROM FRIENDS 3 WHERE STATE LIKE 'C_'; LASTNAME       FIRSTNAME       AREACODE PHONE    ST ZIP\r\n-------------- -------------- --------- -------- -- -----\r\nMERRICK        BUD                  300 555-6666 CO 80212\r\nPERKINS        ALTON                911 555-3116 CA 95633\r\nBOSS           SIR                  204 555-2345 CT 95633"
    },
    {
      "tag": "p",
      "text": "You can use several underscores in a statement:"
    },
    {
      "tag": "h5",
      "text": "INPUT/OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT * 2 FROM FRIENDS 3 WHERE PHONE LIKE'555-6_6_'; LASTNAME       FIRSTNAME       AREACODE PHONE    ST ZIP\r\n-------------- -------------- --------- -------- -- -----\r\nMERRICK        BUD                  300 555-6666 CO 80212\r\nMAST           JD                   381 555-6767 LA 23456"
    },
    {
      "tag": "p",
      "text": "The previous statement could also be written as follows:"
    },
    {
      "tag": "h5",
      "text": "INPUT/OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT * 2 FROM FRIENDS 3 WHERE PHONE LIKE '555-6%'; LASTNAME       FIRSTNAME       AREACODE PHONE    ST ZIP\r\n-------------- -------------- --------- -------- -- -----\r\nMERRICK        BUD                  300 555-6666 CO 80212\r\nMAST           JD                   381 555-6767 LA 23456"
    },
    {
      "tag": "p",
      "text": "Notice that the results are identical. These two wildcards can be combined. The\r\nnext example finds all records with Las the second character:"
    },
    {
      "tag": "h5",
      "text": "INPUT/OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT * 2 FROM FRIENDS 3 WHERE FIRSTNAME LIKE '_L%'; LASTNAME       FIRSTNAME       AREACODE PHONE    ST ZIP\r\n-------------- -------------- --------- -------- -- -----\r\nBUNDY          AL                   100 555-1111 IL 22333\r\nMEZA           AL                   200 555-2222 UK\r\nPERKINS        ALTON                911 555-3116 CA 95633"
    },
    {
      "tag": "h4",
      "text": "Concatenation (||)"
    },
    {
      "tag": "p",
      "text": "The || (double pipe) symbol concatenates two strings. Try this:"
    },
    {
      "tag": "h5",
      "text": "INPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT FIRSTNAME || LASTNAME ENTIRENAME 2 FROM FRIENDS;"
    },
    {
      "tag": "h5",
      "text": "OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "ENTIRENAME\r\n----------------------\r\nAL             BUNDY\r\nAL             MEZA\r\nBUD            MERRICK\r\nJD             MAST\r\nFERRIS         BULHER\r\nALTON          PERKINS\r\nSIR            BOSS 7 rows selected."
    },
    {
      "tag": "h5",
      "text": "ANALYSIS:"
    },
    {
      "tag": "p",
      "text": "Notice that || is used instead of + . If you use + to\r\ntry to concatenate the strings, the SQL interpreter used for this example (Personal\r\nOracle7) returns the following error:"
    },
    {
      "tag": "h5",
      "text": "INPUT/OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT FIRSTNAME + LASTNAME ENTIRENAME\r\n     FROM FRIENDS; ERROR:\r\nORA-01722: invalid number"
    },
    {
      "tag": "p",
      "text": "It is looking for two numbers to add and throws the error invalid number when it doesn't find any. NOTE: Some implementations of SQL use\r\n\tthe plus sign to concatenate strings. Check your implementation. Here's a more practical example using concatenation:"
    },
    {
      "tag": "h5",
      "text": "INPUT/OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT LASTNAME || ',' || FIRSTNAME NAME\r\n     FROM FRIENDS; NAME\r\n------------------------------------------------------\r\nBUNDY    , AL\r\nMEZA     , AL\r\nMERRICK  , BUD\r\nMAST     , JD\r\nBULHER   , FERRIS\r\nPERKINS  , ALTON\r\nBOSS     , SIR 7 rows selected."
    },
    {
      "tag": "h5",
      "text": "ANALYSIS:"
    },
    {
      "tag": "p",
      "text": "This statement inserted a comma between the last name and the first name. NOTE: Notice the extra spaces between\r\n\tthe first name and the last name in these examples. These spaces are actually part\r\n\tof the data. With certain data types, spaces are right-padded to values less than\r\n\tthe total length allocated for a field. See your implementation. Data types will\r\n\tbe discussed on Chapter 9, \"Creating and Maintaining Tables.\" So far you have performed the comparisons one at a time. That method is fine for\r\nsome problems, but what if you need to find all the people at work with last names\r\nstarting with Pwho have less than three days of vacation time?"
    },
    {
      "tag": "h3",
      "text": "Logical Operators"
    },
    {
      "tag": "p",
      "text": "logical operatorsLogical operators separate two or more conditions in the WHERE clause of an SQL statement. Vacation time is always a hot topic around the workplace. Say you designed a table\r\ncalled VACATION for the accounting department:"
    },
    {
      "tag": "h5",
      "text": "INPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT * FROM VACATION;"
    },
    {
      "tag": "h5",
      "text": "OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "LASTNAME       EMPLOYEENUM    YEARS  LEAVETAKEN\r\n-------------- ----------- --------- ----------\r\nABLE                   101        2           4\r\nBAKER                  104        5          23\r\nBLEDSOE                107        8          45\r\nBOLIVAR                233        4          80\r\nBOLD                   210       15         100\r\nCOSTALES               211       10          78 6 rows selected."
    },
    {
      "tag": "p",
      "text": "Suppose your company gives each employee 12 days of leave each year. Using what\r\nyou have learned and a logical operator, find all the employees whose names start\r\nwith Band who have more than 50 days of leave coming."
    },
    {
      "tag": "h5",
      "text": "INPUT/OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT LASTNAME, 2 YEARS * 12 - LEAVETAKEN REMAINING 3 FROM VACATION 4 WHERE LASTNAME LIKE 'B%' 5 AND 6 YEARS * 12 - LEAVETAKEN > 50; LASTNAME       REMAINING\r\n-------------- ---------\r\nBLEDSOE               51\r\nBOLD                  80"
    },
    {
      "tag": "h5",
      "text": "ANALYSIS:"
    },
    {
      "tag": "p",
      "text": "This query is the most complicated you have done so far. The SELECT clause\r\n(lines 1 and 2) uses arithmetic operators to determine how many days of leave each\r\nemployee has remaining. The normal precedence computes YEARS * 12 - LEAVETAKEN .\r\n(Aclearer approach would be to write (YEARS * 12) - LEAVETAKEN .) LIKE is used in line 4 with the wildcard % to find all the Bnames. Line 6 uses the > to find all occurrences greater than 50 . The new element is on line 5. You used the logical operator AND to ensure\r\nthat you found records that met the criteria in lines 4 and 6."
    },
    {
      "tag": "h4",
      "text": "AND"
    },
    {
      "tag": "p",
      "text": "AND means that the expressions on both sides must be true to return TRUE .\r\nIf either expression is false, AND returns FALSE . For example,\r\nto find out which employees have been with the company for 5 years or less\r\nand have taken more than 20 days leave, try this:"
    },
    {
      "tag": "h5",
      "text": "INPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT LASTNAME 2 FROM VACATION 3 WHERE YEARS <= 5 4 AND 5 LEAVETAKEN > 20 ;"
    },
    {
      "tag": "h5",
      "text": "OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "LASTNAME\r\n--------\r\nBAKER\r\nBOLIVAR"
    },
    {
      "tag": "p",
      "text": "If you want to know which employees have been with the company for 5 years or more and have taken less than 50 percent of their leave, you could\r\nwrite:"
    },
    {
      "tag": "h5",
      "text": "INPUT/OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT LASTNAME WORKAHOLICS 2 FROM VACATION 3 WHERE YEARS >= 5 4 AND 5 ((YEARS *12)-LEAVETAKEN)/(YEARS * 12) < 0.50; WORKAHOLICS\r\n---------------\r\nBAKER\r\nBLEDSOE"
    },
    {
      "tag": "p",
      "text": "Check these people for burnout. Also check out how we used the AND to\r\ncombine these two conditions."
    },
    {
      "tag": "h4",
      "text": "OR"
    },
    {
      "tag": "p",
      "text": "You can also use OR to sum up a series of conditions. If any of the comparisons\r\nis true, OR returns TRUE . To illustrate the difference, conditionsrun\r\nthe last query with OR instead of with AND :"
    },
    {
      "tag": "h5",
      "text": "INPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT LASTNAME WORKAHOLICS 2 FROM VACATION 3 WHERE YEARS >= 5 4 OR 5 ((YEARS *12)-LEAVETAKEN)/(YEARS * 12) >= 0.50;"
    },
    {
      "tag": "h5",
      "text": "OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "WORKAHOLICS\r\n---------------\r\nABLE\r\nBAKER\r\nBLEDSOE\r\nBOLD\r\nCOSTALES"
    },
    {
      "tag": "h5",
      "text": "ANALYSIS:"
    },
    {
      "tag": "p",
      "text": "The original names are still in the list, but you have three new entries (who\r\nwould probably resent being called workaholics). These three new names made the list\r\nbecause they satisfied one of the conditions. OR requires that only one\r\nof the conditions be true in order for data to be returned."
    },
    {
      "tag": "h4",
      "text": "NOT"
    },
    {
      "tag": "p",
      "text": "NOT means just that. If the condition it applies to evaluates to TRUE , NOT make it FALSE . If the condition after the NOT is FALSE ,\r\nit becomes TRUE . For example, the following SELECT returns the\r\nonly two names not beginning with Bin the table:"
    },
    {
      "tag": "h5",
      "text": "INPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT * 2 FROM VACATION 3 WHERE LASTNAME NOT LIKE 'B%';"
    },
    {
      "tag": "h5",
      "text": "OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "LASTNAME       EMPLOYEENUM    YEARS LEAVETAKEN\r\n-------------- ----------- -------- ----------\r\nABLE                   101        2          4\r\nCOSTALES               211       10         78"
    },
    {
      "tag": "p",
      "text": "NOT can also be used with the operator IS when applied to NULL .\r\nRecall the PRICES table where we put a NULL value in the WHOLESALE column opposite the item ORANGES ."
    },
    {
      "tag": "h5",
      "text": "INPUT/OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT * FROM PRICE; ITEM           WHOLESALE\r\n-------------- ---------\r\nTOMATOES             .34\r\nPOTATOES             .51\r\nBANANAS              .67\r\nTURNIPS              .45\r\nCHEESE               .89\r\nAPPLES               .23\r\nORANGES 7 rows selected."
    },
    {
      "tag": "p",
      "text": "To find the non- NULL items, type this:"
    },
    {
      "tag": "h5",
      "text": "INPUT/OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT * 2 FROM PRICE 3 WHERE WHOLESALE IS NOT NULL; ITEM           WHOLESALE\r\n-------------- ---------\r\nTOMATOES             .34\r\nPOTATOES             .51\r\nBANANAS              .67\r\nTURNIPS              .45\r\nCHEESE               .89\r\nAPPLES               .23 6 rows selected."
    },
    {
      "tag": "h3",
      "text": "Set Operators"
    },
    {
      "tag": "p",
      "text": "On Chapter 1, \"Introduction to SQL,\" you learned that SQL is based on the\r\ntheory of sets. The following sections examine set operators."
    },
    {
      "tag": "h4",
      "text": "UNION and UNION ALL"
    },
    {
      "tag": "p",
      "text": "UNION returns the results of two queries minus the duplicate rows. The\r\nfollowing two tables represent the rosters of teams:"
    },
    {
      "tag": "h5",
      "text": "INPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT * FROM FOOTBALL;"
    },
    {
      "tag": "h5",
      "text": "OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "NAME\r\n--------------------\r\nABLE\r\nBRAVO\r\nCHARLIE\r\nDECON\r\nEXITOR\r\nFUBAR\r\nGOOBER 7 rows selected."
    },
    {
      "tag": "h5",
      "text": "INPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT * FROM SOFTBALL;"
    },
    {
      "tag": "h5",
      "text": "OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "NAME\r\n--------------------\r\nABLE\r\nBAKER\r\nCHARLIE\r\nDEAN\r\nEXITOR\r\nFALCONER\r\nGOOBER 7 rows selected."
    },
    {
      "tag": "p",
      "text": "How many different people play on one team or another?"
    },
    {
      "tag": "h5",
      "text": "INPUT/OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT NAME FROM SOFTBALL 2 UNION 3 SELECT NAME FROM FOOTBALL; NAME\r\n--------------------\r\nABLE\r\nBAKER\r\nBRAVO\r\nCHARLIE\r\nDEAN\r\nDECON\r\nEXITOR\r\nFALCONER\r\nFUBAR\r\nGOOBER 10 rows selected."
    },
    {
      "tag": "p",
      "text": "UNION returns 10 distinct names from the two lists. How many names are\r\non both lists (including duplicates)?"
    },
    {
      "tag": "h5",
      "text": "INPUT/OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT NAME FROM SOFTBALL 2 UNION ALL 3 SELECT NAME FROM FOOTBALL; NAME\r\n--------------------\r\nABLE\r\nBAKER\r\nCHARLIE\r\nDEAN\r\nEXITOR\r\nFALCONER\r\nGOOBER\r\nABLE\r\nBRAVO\r\nCHARLIE\r\nDECON\r\nEXITOR\r\nFUBAR\r\nGOOBER 14 rows selected."
    },
    {
      "tag": "h5",
      "text": "ANALYSIS:"
    },
    {
      "tag": "p",
      "text": "The combined list--courtesy of the UNION ALL statement--has 14 names. UNION ALL works just like UNION except it does not eliminate duplicates.\r\nNow show me a list of players who are on both teams. You can't do that with UNION --you\r\nneed to learn INTERSECT ."
    },
    {
      "tag": "h4",
      "text": "INTERSECT"
    },
    {
      "tag": "p",
      "text": "INTERSECT returns only the rows found by both queries. The next SELECT statement shows the list of players who play on both teams:"
    },
    {
      "tag": "h5",
      "text": "INPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT * FROM FOOTBALL 2 INTERSECT 3 SELECT * FROM SOFTBALL;"
    },
    {
      "tag": "h5",
      "text": "OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "NAME\r\n--------------------\r\nABLE\r\nCHARLIE\r\nEXITOR\r\nGOOBER"
    },
    {
      "tag": "h5",
      "text": "ANALYSIS:"
    },
    {
      "tag": "p",
      "text": "In this example INTERSECT finds the short list of players who are on\r\nboth teams by combining the results of the two SELECT statements."
    },
    {
      "tag": "h4",
      "text": "MINUS (Difference)"
    },
    {
      "tag": "p",
      "text": "Minus returns the rows from the first query that were not present in\r\nthe second. For example:"
    },
    {
      "tag": "h5",
      "text": "INPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT * FROM FOOTBALL 2 MINUS 3 SELECT * FROM SOFTBALL;"
    },
    {
      "tag": "h5",
      "text": "OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "NAME\r\n--------------------\r\nBRAVO\r\nDECON\r\nFUBAR"
    },
    {
      "tag": "h5",
      "text": "ANALYSIS:"
    },
    {
      "tag": "p",
      "text": "The preceding query shows the three football players who are not on the softball\r\nteam. If you reverse the order, you get the three softball players who aren't on\r\nthe football team:"
    },
    {
      "tag": "h5",
      "text": "INPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT * FROM SOFTBALL 2 MINUS 3 SELECT * FROM FOOTBALL;"
    },
    {
      "tag": "h5",
      "text": "OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "NAME\r\n--------------------\r\nBAKER\r\nDEAN\r\nFALCONER"
    },
    {
      "tag": "h3",
      "text": "Miscellaneous Operators: IN and BETWEEN"
    },
    {
      "tag": "p",
      "text": "The two operators IN and BETWEEN provide a shorthand for functions\r\nyou already know how to do. If you wanted to find friends in Colorado, California,\r\nand Louisiana, you could type the following:"
    },
    {
      "tag": "h5",
      "text": "INPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT * 2 FROM FRIENDS 3 WHERE STATE= 'CA' 4 OR 5 STATE ='CO' 6 OR 7 STATE = 'LA';"
    },
    {
      "tag": "h5",
      "text": "OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "LASTNAME       FIRSTNAME       AREACODE PHONE    ST ZIP\r\n-------------- -------------- --------- -------- -- -----\r\nMERRICK        BUD                  300 555-6666 CO 80212\r\nMAST           JD                   381 555-6767 LA 23456\r\nPERKINS        ALTON                911 555-3116 CA 95633"
    },
    {
      "tag": "p",
      "text": "Or you could type this:"
    },
    {
      "tag": "h5",
      "text": "INPUT/OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT * 2 FROM FRIENDS 3 WHERE STATE IN('CA','CO','LA'); LASTNAME       FIRSTNAME       AREACODE PHONE    ST ZIP\r\n-------------- -------------- --------- -------- -- -----\r\nMERRICK        BUD                  300 555-6666 CO 80212\r\nMAST           JD                   381 555-6767 LA 23456\r\nPERKINS        ALTON                911 555-3116 CA 95633"
    },
    {
      "tag": "h5",
      "text": "ANALYSIS:"
    },
    {
      "tag": "p",
      "text": "The second example is shorter and more readable than the first. You never know\r\nwhen you might have to go back and work on something you wrote months ago. IN also works with numbers. Consider the following, where the column AREACODE is a number:"
    },
    {
      "tag": "h5",
      "text": "INPUT/OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT * 2 FROM FRIENDS 3 WHERE AREACODE IN(100,381,204); LASTNAME       FIRSTNAME       AREACODE PHONE    ST ZIP\r\n-------------- -------------- --------- -------- -- -----\r\nBUNDY          AL                   100 555-1111 IL 22333\r\nMAST           JD                   381 555-6767 LA 23456\r\nBOSS           SIR                  204 555-2345 CT 95633"
    },
    {
      "tag": "p",
      "text": "If you needed a range of things from the PRICE table, you could write\r\nthe following:"
    },
    {
      "tag": "h5",
      "text": "INPUT/OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT * 2 FROM PRICE 3 WHERE WHOLESALE > 0.25 4 AND 5 WHOLESALE < 0.75; ITEM           WHOLESALE\r\n-------------- ---------\r\nTOMATOES             .34\r\nPOTATOES             .51\r\nBANANAS              .67\r\nTURNIPS              .45"
    },
    {
      "tag": "p",
      "text": "Or using BETWEEN , you would write this:"
    },
    {
      "tag": "h5",
      "text": "INPUT/OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT * 2 FROM PRICE 3 WHERE WHOLESALE BETWEEN 0.25 AND 0.75; ITEM            WHOLESALE\r\n-------------- ---------\r\nTOMATOES              .34\r\nPOTATOES              .51\r\nBANANAS               .67\r\nTURNIPS               .45"
    },
    {
      "tag": "p",
      "text": "Again, the second example is a cleaner, more readable solution than the first. NOTE: If a WHOLESALE value of 0.25 existed in the PRICE table, that record would have been retrieved\r\n\talso. Parameters used in the BETWEEN operator are inclusive parametersinclusive."
    },
    {
      "tag": "h2",
      "text": "Summary"
    },
    {
      "tag": "p",
      "text": "At the beginning of Chapter 3, you knew how to use the basic SELECT and FROM clauses. Now you know how to use a host of operators that enable you to fine-tune\r\nyour requests to the database. You learned how to use arithmetic, comparison, character,\r\nlogical, and set operators. This powerful set of tools provides the cornerstone of\r\nyour SQL knowledge."
    },
    {
      "tag": "h2",
      "text": "Q&A"
    },
    {
      "tag": "dd",
      "text": "Q How does all of this information apply to me if Iam not using SQL from\r\n\tthe command line as depicted in the examples?"
    },
    {
      "tag": "p",
      "text": "A Whether you use SQL in COBOL as Embedded SQL or in Microsoft's Open Database\r\n\tConnectivity (ODBC), you use the same basic constructions. You will use what you\r\n\tlearned toChapter and yesterChapter repeatedly as you work with SQL. Q Why are you constantly telling me to check my implementation? Ithought\r\n\tthere was a standard! A There is an ANSI standard (the most recent version is 1992); however,\r\n\tmost vendors modify it somewhat to suit their databases. The basics are similar if\r\n\tnot identical, and each instance has extensions that other vendors copy and improve.\r\n\tWe have chosen to use ANSI as a starting point but point out the differences as we\r\n\tgo along."
    },
    {
      "tag": "h2",
      "text": "Workshop"
    },
    {
      "tag": "p",
      "text": "The Workshop provides quiz questions to help solidify your understanding of the\r\nmaterial covered, as well as exercises to provide you with experience in using what\r\nyou have learned. Try to answer the quiz and exercise questions before checking the\r\nanswers in Appendix F, \"Answers to Quizzes and Exercises.\""
    },
    {
      "tag": "h3",
      "text": "Quiz"
    },
    {
      "tag": "p",
      "text": "Use the FRIENDS table to answer the following questions."
    },
    {
      "tag": "pre",
      "text": "LASTNAME       FIRSTNAME       AREACODE PHONE    ST ZIP\r\n-------------- -------------- --------- -------- -- -----\r\nBUNDY          AL                   100 555-1111 IL 22333\r\nMEZA           AL                   200 555-2222 UK\r\nMERRICK        BUD                  300 555-6666 CO 80212\r\nMAST           JD                   381 555-6767 LA 23456\r\nBULHER         FERRIS               345 555-3223 IL 23332\r\nPERKINS        ALTON                911 555-3116 CA 95633\r\nBOSS           SIR                  204 555-2345 CT 95633"
    },
    {
      "tag": "dd",
      "text": "1. Write a query that returns everyone in the database whose last name\r\n\tbegins with M ."
    },
    {
      "tag": "p",
      "text": "2. Write a query that returns everyone who lives in Illinois with a first\r\n\tname of AL . 3. Given two tables ( PART1 and PART2 ) containing columns\r\n\tnamed PARTNO , how would you find out which part numbers are in both tables?\r\n\tWrite the query. 4. What shorthand could you use instead of WHERE a >= 10 AND a <=30 ? 5. What will this query return?"
    },
    {
      "tag": "pre",
      "text": "SELECT FIRSTNAME\r\nFROM FRIENDS\r\nWHERE FIRSTNAME = 'AL'\r\n  AND LASTNAME = 'BULHER';"
    },
    {
      "tag": "h3",
      "text": "Exercises"
    },
    {
      "tag": "dd",
      "text": "1. Using the FRIENDS table, write a query that returns the following:"
    },
    {
      "tag": "pre",
      "text": "NAME                ST\r\n------------------- --\r\nAL             FROM IL"
    },
    {
      "tag": "h5",
      "text": "INPUT:"
    },
    {
      "tag": "pre",
      "text": "SQL> SELECT (FIRSTNAME || 'FROM') NAME, STATE 2 FROM FRIENDS 3 WHERE STATE = 'IL' 4 AND 5 LASTNAME = 'BUNDY';"
    },
    {
      "tag": "h5",
      "text": "OUTPUT:"
    },
    {
      "tag": "pre",
      "text": "NAME                ST\r\n------------------- --\r\nAL             FROM IL"
    },
    {
      "tag": "dd",
      "text": "2. Using the FRIENDS table, write a query that returns the following:"
    },
    {
      "tag": "pre",
      "text": "NAME                       PHONE\r\n-------------------------- -------------\r\nMERRICK, BUD               300-555-6666\r\nMAST, JD                   381-555-6767\r\nBULHER, FERRIS             345-555-3223"
    },
    {
      "tag": "div",
      "text": "BEGIN RICH-MEDIA BURST! CODE END BURST CODE | About us | Categories | New Releases | Most Popular | Web Tutorial | Free Download | Drivers | BEGIN RICH-MEDIA BURST! CODE END BURST CODE 2004 Soft Lookup Corp. Privacy Statement"
    }
  ]
}